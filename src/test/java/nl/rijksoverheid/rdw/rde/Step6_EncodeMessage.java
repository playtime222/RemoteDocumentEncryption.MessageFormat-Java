package nl.rijksoverheid.rdw.rde;


import nl.rijksoverheid.rdw.rde.messaging.FileArgs;
import nl.rijksoverheid.rdw.rde.messaging.MessageContentArgs;
import nl.rijksoverheid.rdw.rde.messaging.RdeMessageDecryptionInfo;
import nl.rijksoverheid.rdw.rde.messaging.zipV2.ZipMessageEncoder;
import org.bouncycastle.util.encoders.Hex;
import org.junit.Assert;
import org.junit.jupiter.api.Test;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;


//Generates test data for cross-platform tests and checks the generation by round-tripping by using the decode test.
//NB files from other platforms may differ at the byte level BUT will still decode correctly
//NB The files generated by other platforms can differ by type or level of compression, 64 or 32 bit, etc.
//NB This is compounded by adding a zip entry takes its timestamps from the OS and so the metadata in the zip differs too.
//The approach taken here is to decode the output to check that the message has the same content.
//The decoding tests are used to check the encoding from other platforms
public class Step6_EncodeMessage
{
    private static void test(String name) throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, IllegalBlockSizeException, NoSuchPaddingException, IOException, BadPaddingException, InvalidKeyException {
        var tc = TestCases.Items.get(name);
        var actual = generate(name);
        Step7_DecodeMessage.test(tc.MessageEncryptionKey, actual);
    }

    private static String generate(final String name) throws InvalidAlgorithmParameterException, NoSuchPaddingException, IllegalBlockSizeException, IOException, NoSuchAlgorithmException, BadPaddingException, InvalidKeyException {
        var tc = TestCases.Items.get(name);

        var messageContentArgs = new MessageContentArgs();
        messageContentArgs.add(new FileArgs("argle", "argle...".getBytes(StandardCharsets.UTF_8)));
        messageContentArgs.setUnencryptedNote("note");

        var rdeMessageDecryptionInfo = new RdeMessageDecryptionInfo();
        rdeMessageDecryptionInfo.setCommand("Now!");
        rdeMessageDecryptionInfo.setPcdPublicKey("01");

        var secretKey = new SecretKeySpec(Hex.decode(tc.MessageEncryptionKey), "AES");

        var encoder = new ZipMessageEncoder();
        var encoded = encoder.encode(messageContentArgs, rdeMessageDecryptionInfo, secretKey);
        var encodedHex = Hex.toHexString(encoded);

        System.out.println("Secret Key : " + tc.MessageEncryptionKey);
        System.out.println("Actual     : " + encodedHex);

        return encodedHex;
    }

    @Test
    public void generate1() throws GeneralSecurityException, IOException { generate("J 1"); }
    @Test
    public void test1() throws GeneralSecurityException, IOException { test("J 1"); }

    /*Useful for seeing if the zip has been written correctly - try opening in 7Zip and look for CRC errors on the entries.*/
    //@Test void DumpToFile() throws IOException {
    //    var f = new FileOutputStream("Message.zip");
    //    f.write(Hex.decode(Case1_Length10_Message));
    //    f.close();
    //}
}